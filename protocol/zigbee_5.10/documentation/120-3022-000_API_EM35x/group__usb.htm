<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EmberZNet API Reference: For the EM35x SoC Platform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td><img src="SiliconLabsLogo_Black.jpg" style="padding: 10px;width:40%;height:40%;" /></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">EmberZNet API Reference: For the EM35x SoC Platform
   &#160;<span id="projectnumber">EmberZNet 5.10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__usb.htm','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">USB Device Stack Library</div>  </div>
<div class="ingroups"><a class="el" href="group__hal.htm">Hardware Abstraction Layer (HAL) API Reference</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__USB__COMMON"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__COMMON.htm">USB_COMMON</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__USB__DEVICE"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.htm">USB_DEVICE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<pre class="fragment"> The source files for the USB device stack resides in the usb directory
 and follows the naming convention: em_usbd&lt;em&gt;nnn&lt;/em&gt;.c/h.

 @li @ref usb_device_intro
 @li @ref usb_device_api
 @li @ref usb_device_conf

 @n @section usb_device_intro Introduction

 The USB device protocol stack provides an API which makes it possible to
 create USB devices with a minimum of effort. The device stack supports control,
 bulk and interrupt transfers.

 The stack is highly configurable to suit various needs, it does also contain
 useful debugging features together with several demonstration projects to
 get you started fast.

 We recommend that you read through this documentation, then proceed to build
 and test a few example projects before you start designing your own device.

 @n @section usb_device_api The device stack API

 This section contains brief descriptions of the functions in the API. You will
 find detailed information on input and output parameters and return values by
 clicking on the hyperlinked function names. It is also a good idea to study
 the code in the USB demonstration projects.

 Your application code must include one header file: @em em_usb.h.

 All functions defined in the API can be called from within interrupt handlers.

 &lt;b&gt;Pitfalls:&lt;/b&gt;@n
  The USB peripheral will fill your receive buffers in quantities of WORD's
  (4 bytes). Transmit and receive buffers must be WORD aligned, in
  addition when allocating storage for receive buffers, round size up to
  next WORD boundary. If it is possible that the host will send more data
  than your device expects, round buffer size up to the next multiple of
  maxpacket size for the relevant endpoint to avoid data corruption.

  Transmit buffers passed to @htmlonly USBD_Write() @endhtmlonly must be
  statically allocated because @htmlonly USBD_Write() @endhtmlonly only
  initiates the transfer. When the host decide to actually perform the
  transfer, your data must be available.

 @n @ref USBD_Init() @n
  This function is called to register your device and all its properties with
  the device stack. The application must fill in a @ref USBD_Init_TypeDef
  structure prior to calling. Refer to @ref DeviceInitCallbacks for the
  optional callback functions defined within this structure. When this
  function has been called your device is ready to be enumerated by the USB
  host.

 @ref USBD_Read(), @ref USBD_Write() @n
  These functions initiate data transfers.
  @n @htmlonly USBD_Read() @endhtmlonly initiate a transfer of data @em
  from host @em to device (an @em OUT transfer in USB terminology).
  @n @htmlonly USBD_Write() @endhtmlonly initiate a transfer of data @em from
  device @em to host (an @em IN transfer).

  When the USB host actually performs the transfer, your application will be
  notified by means of a callback function which you provide (optionally).
  Refer to @ref TransferCallback for details of the callback functionality.

 @ref USBD_AbortTransfer(), @ref USBD_AbortAllTransfers() @n
  These functions terminate transfers that are initiated, but has not yet
  taken place. If a transfer is initiated with @htmlonly USBD_Read()
  or USBD_Write(), @endhtmlonly but the USB host never actually peform
  the transfers, these functions will deactivate the transfer setup to make
  the USB device endpoint hardware ready for new (and potentially) different
  transfers.

 @ref USBD_Connect(), @ref USBD_Disconnect() @n
  These functions turns the data-line (D+ or D-) pullup on or off. They can be
  used to force reenumeration. It's good practice to delay at least one second
  between @htmlonly USBD_Disconnect() and USBD_Connect() @endhtmlonly
  to allow the USB host to unload the currently active device driver.

 @ref USBD_EpIsBusy() @n
  Check if an endpoint is busy.

 @ref USBD_StallEp(), @ref USBD_UnStallEp() @n
  These functions stalls or un-stalls an endpoint. This functionality may not
  be needed by your application, but the USB device stack use them in response
  to standard setup commands SET_FEATURE and CLEAR_FEATURE. They may be useful
  when implementing some USB classes, e.g. a mass storage device use them
  extensively.

 @ref USBD_RemoteWakeup() @n
  Used in SUSPENDED state (see @ref USB_Status_TypeDef) to signal resume to
  host. It's the applications responsibility to adhere to the USB standard
  which states that a device can not signal resume before it has been
  SUSPENDED for at least 5 ms. The function will also check the configuration
  descriptor defined by the application to see if it is legal for the device
  to signal resume.

 @ref USBD_GetUsbState() @n
  Returns the device USB state (see @ref USBD_State_TypeDef). Refer to
  Figure 9-1. "Device State Diagram" in the USB revision 2.0 specification.

 @ref USBD_GetUsbStateName() @n
  Returns a text string naming a given USB device state.

 @n @anchor TransferCallback &lt;b&gt;The transfer complete callback function:&lt;/b&gt; @n
  @n USB_XferCompleteCb_TypeDef() is called when a transfer completes. It is
  called with three parameters, the status of the transfer, the number of
  bytes transferred and the number of bytes remaining. It may not always be
  needed to have a callback on transfer completion, but you should keep in
  mind that a transfer may be aborted when you least expect it. A transfer
  will be aborted if host stalls the endpoint, if host resets your device, if
  host unconfigures your device or if you unplug your device cable and the
  device is selfpowered.
  @htmlonly USB_XferCompleteCb_TypeDef() @endhtmlonly is also called if your
  application use @htmlonly USBD_AbortTransfer() or USBD_AbortAllTransfers()
  @endhtmlonly calls.
  @note This callback is called from within an interrupt handler with
        interrupts disabled.

 @n @anchor DeviceInitCallbacks &lt;b&gt;Optional callbacks passed to the stack via
  the @ref USBD_Init() function:&lt;/b&gt; @n
  @n These callbacks are all optional, and it is up to the application
  programmer to decide if the application needs the functionality they
  provide.
  @note These callbacks are all called from within an interrupt handler
        with interrupts disabled.

 USBD_UsbResetCb_TypeDef() is called each time reset signalling is sensed on
  the USB wire.

 @n USBD_SofIntCb_TypeDef() is called with framenumber as a parameter on
  each SOF interrupt.

 @n USBD_DeviceStateChangeCb_TypeDef() is called whenever the device state
  change. Useful for detecting e.g. SUSPENDED state change in order to reduce
  current consumption of buspowered devices. The USB HID keyboard example
  project has a good example on how to use this callback.

 @n USBD_IsSelfPoweredCb_TypeDef() is called by the device stack when host
  queries the device with a standard setup GET_STATUS command to check if the
  device is currently selfpowered or buspowered. This feature is only
  applicable on selfpowered devices which also works when only buspower is
  available.

 @n USBD_SetupCmdCb_TypeDef() is called each time a setup command is
  received from host. Use this callback to override or extend the default
  handling of standard setup commands, and to implement class or vendor
  specific setup commands. The USB HID keyboard example project has a good
  example on how to use this callback.

 @n @section usb_device_conf Configuring the device stack

 Your application must provide a header file named @em usbconfig.h. This file
 must contain the following \#define:@n @n
 @verbatim 
</pre><p> #define NUM_EP_USED n // Your application use 'n' endpoints in</p>
<ul>
<li>// addition to endpoint 0.  </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<table border="0" cellspacing="0" cellpadding="0" width=100%>
<tr>
<td><address><small>
EmberZNet API Reference: For the EM35x SoC Platform. EmberZNet 5.10.0.0.
</small></address>
</td>
<td align="right">
<address><small>
</small></address>
</td>
</tr>
</table>
</body>
</html>
